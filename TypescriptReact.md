# Interview list

\\ List of questions and tasks for interview

## TypeScript

1. Зачем нужен TypeScript? Какие плюсы и минусы использования TS в проекте?
   - Основное предназначение языка - помощь при разработке.
   - Строгая типизация
   - Читаемость кода
   - Зачем TS компилировать? Typescript - компилируемый язык, он преобразует свой код в JavaScript, но не исполняется самостоятельно.
2. В чем разница между типами и интерфейсами?
   - Идеологически interface - контракт в ооп стиле и позволяет орпределять четкую статическую структуру, а type - просто псевдоним
   - Функциональное различие, в том что 2 интерфейса с одинаковым именем будут объеденены, а с типом такое не работает
3. Как можно все-таки унаследовать типы?
   - Через инструмент объединения.
4. Что такое union type?
   - Это просто тип с несколькими возможными типами внутри. (Dog | Cat | Rat)
5. Есть ли разница между propA и propB?
   - Да, есть. Первый пропс должен быть обязательно прокинут при вызове компонента, но его значение мб undefined. Второй пропс может не прикидываться в компонент.
6. Есть ли разница между объединением типов с наследованием интерфейсов?
   - Да, интерфейсы эффективнее под капотом
7. В чем разница между пересечением и объединением типов?
   - Объелинение требует соблюдение всей структуры данных
   - Пересечению достаточно хотя бы одного
8. Можно ли комбинировать наследование интерфейсов и объединение типов?
   - Да, главное поддерживать консистентность типов, а объединение и наследование работает в обе стороны

```typescript
// 5
interface Type {
  propA: string | undefined;
  propB?: string;
}

const ReactComponent = (props: Type) => null;

// 7
type A = {
  a: string;
  c: boolean;
};

type B = {
  b: number;
  c: boolean;
};

type Z = {
  d: number;
  c: string;
};

type C = A & B; // a - require, b - require, c - require
type D = A | B; // c - requre, b | a - require
type X = A & Z; // X - never because of types can't select correct type of field - c
type Y = B & Z; // Y - a & c - reuqire | d & c - require with correct types

// 8
interface C extends B, A {
  d: number;
}

type D = B & A & { d: number };

// C equal D as data type
```

9. Что это такое Enum?
   - Перечислимый тип данных
10. Стоит ли использовать? Какие плюсы и минусы видишь?
11. Что такое generic тип и зачем?

- Обобщение типов, необходимое для реализации более универсальной логики для функций, классов или компонентов (множественный тип)

12. Что такое utility types? Какие применял? Зачем они нужны?

- Omit - исключение из типа
- Pick - сохранение из типа
- Record - маппинг из типа
- Partial - делает поля типа не ообязательными
- Readonly - делает поля объекта не мутабельными
- Exclude - исключение типа из пересечения
- Extract - сохранение типа из пересечения
- NonNullable - исключение всех nullable типов из пересечения
- Parameters - составление кортежа из аргуметов функции, переданных к качестве типа
- ConstructorParameters - создание кортежа из аргументов функции конструктора класса
- ReturnType - создает тип возвращаемого значения функции
- InstanceType - создает тип из публичных полей класса, приватные поля не могут быть использованы и поэтому будет ошибка
- ThisParameterType - Извлекает тип параметра this для типа функции или unknown , если тип функции не имеет thisпараметра.
- OmitThisParameter - Удаляет this параметр из Type. Если Type не имеет явно объявленного this параметра, результатом будет просто Type. В противном случае this из Type. Обобщения стираются, и только последняя сигнатура перегрузки распространяется на новый тип функции.
- ThisType - Эта утилита не возвращает преобразованный тип. Вместо этого он служит маркером для контекстного this типа. Обратите внимание, что noImplicitThis флаг должен быть включен, чтобы использовать эту утилиту.

13. Как работает типизация в TS? Насколько она полноценная?

- Типизация в TS структурная. Это значит, что объект является определенного типа, если его атрибуты подходят этому типу. При этом сам объект может быть шире указанного типа, но не уже.

14. Чем any отличается от unknown?

- Any - может быть супертипом и подтипом для любого типа, unknown - только супертипом.

15. Что можно настроить в ts-config?

- always-strict. Что это дает?
- алиасы для поиска типов
- наследование от другого конфига.
- корневую директорию
- исключаемые и включаемые директории

16. Что такое brand types, и для чего это нужно?

- Создание уникальных типов для идентификации сущности, если сущность при этом всегда строка например

```typescript
// FOO
interface FooId extends String {
  _fooIdBrand: string; // To prevent type errors
}

// BAR
interface BarId extends String {
  _barIdBrand: string; // To prevent type errors
}

/**
 * Usage Demo
 */
var fooId: FooId;
var barId: BarId;

// Safety!
fooId = barId; // error
barId = fooId; // error
fooId = <FooId>barId; // error
barId = <BarId>fooId; // error

// Newing up
fooId = 'foo' as any;
barId = 'bar' as any;

// If you need the base string
var str: string;
str = fooId as any;
str = barId as any;
```

## React

1. Функциональное или класс-ориентированное программирование.
2. Хуки

   1. Базовые хуки. Какие есть и какие правила для хуков существуют. Почему?
      1. нейминг с use
      2. Использование только в верхнеуровнем scope компонента или другого хука - нельзя использовать в условиях, циклах и других блочных операциях
      3. Реакт требует одинаковую последовательность вызова хуков, поэтому нужно вызывать их только в верхеуровневом scope компонента/хука
   2. Для чего могут понадобиться кастомные хуки и чем они отличаются от обычных функций?
      1. Нужны для решения различных задач необходимых разработчику, позволяют уменьшить дублируемую логику, упрощают читабельность кода и т д
      2. В отличии от функций хуки внутри под капотом как правило использую другие хуки, для управления состоянием или вычислением какой-либо логики, поэтому они вынуждены подчиняться правилам хуков
   3. ::Middle:: Зачем нужен useLayoutEffect?
      Хук полностью идентичен useEffect по интерфейсу, но у него есть ключевая особенность - он блокирует отрисовку dom дерева в браузере, пока синхронно не выполнит свою логику = componentDidMount, при это useEffect работает асинхронно и выполнится после первого рендеринга

3. Tree shaking.

   1. Зачем нужен key в отрисовке массивов? Когда допустимо использовать index, а когда - нет.
      1. Реакт полагается на key чтобы явно понять какие элементы в списке изменелись
      2. Использование индекса нельзя использовать в списках, которые будут меняться - например элемент удалится, это может привести к сайд эффектам
   2. Как react сравнивает DOM и VirtualDOM?
      Сверху вниз, ровно до измененного узла, если родительский узел изменился, то вся ветка после него будет переопределяться и рендериться заново
   3. ::Middle:: Что такое ShadowDOM и где используется?
      Используется для инкапсуляции. Благодаря ему в компоненте есть собственное «теневое» DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д. Подсмотреть теневое дерево можно в Chrome в режиме разработчика, если включить такой флаг в настройках
   4. ::Middle:: Что вызывает повторный рендер компонента?
      1. Изменение родительского компонента
      2. Изменение состояния самого компонента - куча вариантов что могло поменять состояние, пользователь, вычисление, асинхронные запросы и т д

4. Оптимизация. Какие есть способы оптимизации?

   1. React.memo и useMemo, useCallback, useRef (Подробнее ниже)
   2. React.lazy
   3. Trottle & debounce
   4. Кеширование результата выполнения функции

5. ::Middle:: React memoization
   1. Когда используем memo?
      1. Каждый раз когда компонент принимает пропсы (кроме ситуации когда родитель ререндериться и у ребенка обновляются все 100% пропсов каждый раз)
      2. Каждый раз когда пропсов нет, т к это позволяет отрендерить компонент только один раз и родитель больше не тригерит его ререндеры
   2. Когда используем `useCallback`?
      1. Нужно использовать при оборачивании метода родителя, который используется в дочерних компонентах в виде пропса (но не имеет смысла в нативных html(jsx) элементах(div, button, input и т д))
   3. Потребление контекста `useSelector` для оптимальной работы react
      1. Чтобы не подписываться в компоненте на состояние крупного куска стейта нужно вытаскивать из редакса только ту часть которая нужна в моменте, не тащить больше необходимого (у нас все ок в целом с этим) достигается деструктуризацией или селекторами
      2. `const fullEntity = useFullEntityState();` - плохо, кроме тех случаев когда нужен весь стейт, но лучше минимизировать такие случаи
      3. `const {data1, data2} = useFullEntityState()` - хорошо
   4. Как правильно использовать `useMemo` и когда это излишне?
      1. Если нужно мемоизировать объект, то стоит подумать, какие примитивные зависимости обеспечивают пересчет объекта, `useMemo(() => instrument.someObjectProp,[instrument.id])`
      2. Простое вычисление примитива необязательно оборачивать в `useMemo`, например, конкатенация строк выполнится быстрее, чем сравнение массива зависимостей.
